// Grabs a folder and generates a go file with a map
package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"

	"github.com/cheggaaa/pb"
)

var (
	flagHandler bool
	flagNoBak   bool
)

func main() {
	flag.BoolVar(&flagHandler, "handler", false, "Generates http handlerFunc")
	flag.BoolVar(&flagNoBak, "nobackup", false, "Does not write a .bak if .go file exists")
	flag.Parse()

	if flag.NArg() < 2 {
		fmt.Fprintln(os.Stderr, "This will create a folder named by [pkgname] and add the generated file")
		fmt.Fprintln(os.Stderr, "usage: ", os.Args[0], "[folder] [pkgname] <destination>")
		flag.PrintDefaults()
		return
	}

	var folder, err = filepath.Abs(flag.Args()[0])
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error on dir:", err)
		return
	}
	var pkg = filepath.Base(flag.Args()[1]) // Remove trailing '/'
	dst := pkg
	if flag.NArg() >= 3 {
		dst = flag.Args()[2]
	}
	// Data where it will be transformed to a Go file
	var data = map[string]string{}

	_, err = os.Stat(folder)
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error opening dir", folder, err)
		return
	}

	// For every file
	filepath.Walk(folder, func(fpath string, f os.FileInfo, err error) error {
		if f.IsDir() {
			return nil // Continue
		}
		// Get ABSPATH
		absFolder, err := filepath.Abs(folder)
		if err != nil {
			return err
		}
		absPath, err := filepath.Abs(fpath)
		if err != nil {
			return err
		}

		kfname := absPath[len(absFolder)+1:] // remove slash?
		buf := bytes.NewBuffer(nil)
		writeHexFile(buf, absFolder, kfname, f)

		data[kfname] = buf.String()

		return nil
	})

	targetFile := fmt.Sprintf("%s/%s.go", dst, pkg)

	// Check if file exists
	if !flagNoBak {
		_, err = os.Stat(targetFile)
		if err == nil || !os.IsNotExist(err) { // File exists
			err := os.Rename(targetFile, targetFile+".bak") // can fail
			if err != nil {
				panic(err)
			}
		}
	}

	// Write golang file
	os.MkdirAll(dst, os.FileMode(0755))
	f, err := os.OpenFile(fmt.Sprintf("%s/%s.go", dst, pkg), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(0644))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	// Template would be good here
	fmt.Fprintf(f, "// Package %s -- Generated by folder2go\n", pkg)
	fmt.Fprintf(f, "package %s\n\n", pkg)

	// If we want http support
	// Templates would be nice here
	if flagHandler {
		fmt.Fprint(f, `
import (
	"mime"
	"net/http"
	"path/filepath"
	"strings"
)
	`)
	}

	fmt.Fprintf(f, "//Data exported data taken from folder %s\n", folder)
	fmt.Fprint(f, "var Data = map[string][]byte {\n")
	for k, v := range data {
		fmt.Fprintf(f, "\t\"%s\":\t\t[]byte{\n%s\n},\n", k, v)
	}
	fmt.Fprintf(f, "}\n")

	if flagHandler {
		fmt.Fprint(f, `
func AssetHandleFunc(w http.ResponseWriter, r *http.Request) {
	urlPath := ""

	// func that handles mux
	server := r.Context().Value(http.ServerContextKey).(*http.Server)
	mux, ok := server.Handler.(*http.ServeMux)
	if ok {
		_, handlerPath := mux.Handler(r)
		urlPath = strings.TrimPrefix(r.URL.String(), handlerPath)
	}
	if urlPath == "" { // Auto index
		urlPath = "index.html"
	}
	data, ok := Data[urlPath]
	if !ok {
		w.WriteHeader(404)
	}

	w.Header().Set("Content-type", mime.TypeByExtension(filepath.Ext(urlPath)))
	w.Write(data)
}`)
	}

}

func writeHexFile(w io.Writer, curDir, fname string, f os.FileInfo) error {
	// Send file through channel?
	// Open file
	fin, err := os.Open(filepath.Join(curDir, fname))
	if err != nil {
		log.Fatal(err)
		return err
	}

	// File Processor
	buf := make([]byte, 4096)
	fmt.Fprintln(os.Stderr, "Processing file:", fname)
	bar := pb.StartNew(int(f.Size()))
	totN := 0
	for {
		n, err := fin.Read(buf)
		if err != nil && err != io.EOF {
			fmt.Fprintln(os.Stderr, "Err:", err)
			break
		}
		totN += n
		//fmt.Fprintf(os.Stderr, "\n%s - %d of %d", kfname, totN, f.Size())
		bar.Add(n)
		for i, v := range buf[:n] {
			if (i+totN)%80 == 0 {
				fmt.Fprintf(w, "\n\t\t")
			}
			fmt.Fprintf(w, "0x%02X, ", v)
		}
		if err == io.EOF {
			break
		}
	}
	bar.Finish()
	return nil

}
