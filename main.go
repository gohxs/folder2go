// Grabs a folder and generates a go file with a map
package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

var (
	flagHandler bool
)

func main() {
	flag.BoolVar(&flagHandler, "handler", false, "Generates http handlerFunc")
	flag.Parse()

	if flag.NArg() < 2 {
		fmt.Println("This will create a folder named by [pkgname] and add the generated file")
		fmt.Println("usage: ", os.Args[0], "[folder] [pkgname] <destination>")
		flag.PrintDefaults()
		return
	}

	var folder = flag.Args()[0]
	var pkg = filepath.Base(flag.Args()[1]) // Remove trailing '/'
	dst := pkg
	if flag.NArg() >= 3 {
		dst = flag.Args()[2]
	}
	var data = map[string]string{}

	filepath.Walk(folder, func(fpath string, f os.FileInfo, err error) error {
		if f.IsDir() {
			return nil // Continue
		}
		// Get ABSPATH
		absFolder, err := filepath.Abs(folder)
		if err != nil {
			return err
		}
		absPath, err := filepath.Abs(fpath)
		if err != nil {
			return err
		}

		kfname := absPath[len(absFolder)+1:] // remove slash?

		log.Printf("Processing: %s ", kfname)
		fdata, err := ioutil.ReadFile(fpath)
		if err != nil {
			log.Fatal(err)
			return err
		}
		vardata := ""
		for _, v := range fdata {
			vardata += fmt.Sprintf("\\x%02X", v)
		}
		data[kfname] = vardata

		return nil
	})

	targetFile := fmt.Sprintf("%s/%s.go", dst, pkg)

	// Check if file exists
	_, err := os.Stat(targetFile)
	if err == nil || !os.IsNotExist(err) { // File exists
		err := os.Rename(targetFile, targetFile+".bak") // can fail
		if err != nil {
			panic(err)
		}
	}

	// Write golang file
	os.MkdirAll(dst, os.FileMode(0755))
	f, err := os.OpenFile(fmt.Sprintf("%s/%s.go", dst, pkg), os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(0644))
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Package %s -- Generated by folder2go\n", pkg)
	fmt.Fprintf(f, "package %s\n\n", pkg)

	// If we want http support
	// Templates would be nice here
	if flagHandler {
		fmt.Fprint(f, `
import (
	"mime"
	"net/http"
	"path/filepath"
	"strings"
)
	`)
	}

	fmt.Fprintf(f, "//Data exported data taken from folder %s\n", folder)
	fmt.Fprint(f, "var Data = map[string][]byte {\n")
	for k, v := range data {
		fmt.Fprintf(f, "\t\"%s\":\t\t[]byte(\"%s\"),\n", k, v)
	}
	fmt.Fprintf(f, "}\n")

	if flagHandler {
		fmt.Fprint(f, `
func AssetHandleFunc(w http.ResponseWriter, r *http.Request) {
	urlPath := ""

	// func that handles mux
	server := r.Context().Value(http.ServerContextKey).(*http.Server)
	mux, ok := server.Handler.(*http.ServeMux)
	if ok {
		_, handlerPath := mux.Handler(r)
		urlPath = strings.TrimPrefix(r.URL.String(), handlerPath)
	}
	if urlPath == "" { // Auto index
		urlPath = "index.html"
	}
	data, ok := Data[urlPath]
	if !ok {
		w.WriteHeader(404)
	}

	w.Header().Set("Content-type", mime.TypeByExtension(filepath.Ext(urlPath)))
	w.Write(data)
}`)
	}

}
